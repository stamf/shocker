#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail; shopt -s nullglob
btrfs_path='/var/bocker' && cgroups='cpu,cpuacct,memory' && repo='../.bocker-repo';
#shellcheck disable=SC2015
[[ $# -gt 0 ]] && while [ "${1:0:2}" == '--' ]; do OPTION=${1:2}; [[ $OPTION =~ = ]] && declare "BOCKER_${OPTION/=*/}=${OPTION/*=/}" || declare "BOCKER_${OPTION}=x"; shift; done


# check if btrfs is mounted and available
set +e
[ -d "$btrfs_path" ] || mkdir -p "$btrfs_path"
sudo btrfs filesystem show "$btrfs_path" > /dev/null
[ "$?" -ne 0 ] && {
  printf 'Error: %s is not a btrfs filesystem\n' "$btrfs_path"
  exit 1
}
set -e

function ip_to_int() { #Transform ipv4 address into int
    local IFS='[./]'
    #shellcheck disable=SC2086
    set -- $1
    echo $(($1 * 256**3 + $2 * 256**2 + $3 * 256**1 + $4))
}

function int_to_ip() { #Transform int into ipv4 address
    printf "%d.%d.%d.%d" \
        $((($1 & 256**4-1) / 256**3)) \
        $((($1 & 256**3-1) / 256**2)) \
        $((($1 & 256**2-1) / 256**1)) \
        $(( $1 & 256**1-1))
}

function int_to_mac() { #Transform int into mac address
    printf "02:42:%02x:%02x:%02x:%02x" \
        $((($1 & 256**4-1) / 256**3)) \
        $((($1 & 256**3-1) / 256**2)) \
        $((($1 & 256**2-1) / 256**1)) \
        $(( $1 & 256**1-1))
}

function addr_to_network() { #Transforms ip/mask into an int representing the network
    local IFS=/
    #shellcheck disable=SC2086
    set -- $1
    mask=$(((2**$2-1) * 2**(32-$2)))
    addr=$(ip_to_int "$1")
    echo $((addr & mask))
}

function addr_to_hostid() { #Transforms ip/mask into an int representing the host
    local IFS=/
    #shellcheck disable=SC2086
    set -- $1
    mask=$((2**(32-$2)-1))
    addr=$(ip_to_int "$1")
    echo $((addr & mask))
}

#shellcheck disable=SC1091
source ./network.conf
MASK=${NETWORK##*/}
NHOSTS=$((2**(32-MASK)))
NETWORK=$(addr_to_network "$NETWORK")
GATEWAY=$((NETWORK + 1))

function gen_uuid() {
    shuf -i 2-$NHOSTS -n 1
}

function bocker_check() {
    btrfs subvolume list "$btrfs_path" | grep -qw "$1" && echo 0 || echo 1
}

function bocker_init() { #HELP Create an image from a directory:\nBOCKER init <directory>
    uuid="img_$(shuf -i 42002-42254 -n 1)"
    if [[ -d "$1" ]]; then
        [[ "$(bocker_check "$uuid")" == 0 ]] && bocker_run "$@"
        btrfs subvolume create "$btrfs_path/$uuid" > /dev/null
        cp -rf --reflink=auto "$1"/* "$btrfs_path/$uuid" > /dev/null
        [[ ! -f "$btrfs_path/$uuid"/img.source ]] && echo "$1" > "$btrfs_path/$uuid"/img.source
        echo "Created: $uuid"
    else
        echo "No directory named '$1' exists"
    fi
}

function bocker_pull() { #HELP Pull an image from Docker Hub:\nBOCKER pull <name> <tag>
    [ -d '/tmp' ] || { printf 'Error: /tmp does not exist'; exit 1; }

    fn_get_registry () {
      curl -sL -o /dev/null -D- \
        -H 'X-Docker-Token: true' \
        "https://index.docker.io/v1/repositories/$1/images" \
        | tr -d '\r' \
        | awk -F ': *' '$1 == "X-Docker-Token" { print $2 }'
    }

    fn_get_id () {
      curl -sL -H "Authorization: Token $token" \
        "$registry/repositories/$1/tags/$2" \
        | sed 's/"//g'
    }

    fn_get_ancestry () {
      curl -sL \
        -H "Authorization: Token $token" \
        "$registry/images/$id/ancestry"
    }

    token="$(fn_get_registry "$1")"
    registry='https://registry-1.docker.io/v1'
    id="$(fn_get_id "$1" "$2")"
    [ "${#id}" -ne 64 ] && echo "No image named '$1:$2' exists" && exit 1

    ancestry="$(fn_get_ancestry)"
    local IFS=','
    local ancestry=(${ancestry//[\[\] \"]/})

    local IFS=' \n\t'
    local tmp_uuid="img_$RANDOM"
    mkdir /tmp/"$tmp_uuid"
    for id in "${ancestry[@]}"; do
        curl -#L -H "Authorization: Token $token" \
          "$registry/images/$id/layer" \
          -o /tmp/"$tmp_uuid"/layer.tar
        tar xf /tmp/"$tmp_uuid"/layer.tar -C /tmp/"$tmp_uuid" 
        rm /tmp/"$tmp_uuid"/layer.tar
    done

    echo "$1:$2" > /tmp/"$tmp_uuid"/img.source
    bocker_init /tmp/"$tmp_uuid"
    rm -rf /tmp/"$tmp_uuid"
}

function bocker_rm() { #HELP Delete an image or container:\nBOCKER rm <image_id or container_id>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1
    btrfs subvolume delete "$btrfs_path/$1" > /dev/null
    cgdelete -g "$cgroups:/$1" &> /dev/null || true
    echo "Removed: $1"
}

function bocker_images() { #HELP List images:\nBOCKER images
    echo -e "IMAGE_ID\t\tSOURCE"
    for img in "$btrfs_path"/img_*; do
        img=$(basename "$img")
        echo -e "$img\t\t$(cat "$btrfs_path/$img/img.source")"
    done
}

function get_state() {
    [[ ! -d "$btrfs_path/$1" ]] && echo missing && return
    [[ -d "/sys/fs/cgroup/cpuacct/$1" ]] && cgdef=1 || cgdef=0
    grep -q . "/sys/fs/cgroup/cpuacct/$1/tasks" 2>/dev/null && procs=1 || procs=0
    ip netns show | grep -q "netns_$1" 2>/dev/null && netns=1 || netns=0
    ip link show | grep -q "veth0_$1" 2>/dev/null && veth=1 || veth=0

    state=crashed
    [[ $((cgdef & procs & netns & veth)) -eq 1 ]] && state=running
    [[ $((cgdef | procs | netns | veth)) -eq 0 ]] && state=stopped

    echo $state
}

function bocker_ps() { #HELP List containers:\nBOCKER ps
    echo -e "CONTAINER_ID\t\tSTATE\t\tCOMMAND"
    #shellcheck disable=SC2012
    ls -rtd "$btrfs_path"/ps_* | while read -r ps; do
        ps=$(basename "$ps")
        state=$(get_state "$ps")

        case $state in
            running) state="\x1b[1;32m$state\x1b[0m";;
            crashed) state="\x1b[1;31m$state\x1b[0m";;
        esac

        echo -e "$ps\t\t$state\t\t$(cat "$btrfs_path/$ps/$ps.cmd")"
    done
}

function bocker_pre_run() {
    uuid=$(gen_uuid)
    cntid="ps_$uuid"
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No image named '$1' exists" && exit 1
    [[ "$(bocker_check "$cntid")" == 0 ]] && echo "UUID conflict, retrying..." && return #&& bocker_run "$@" && return
    #TODO uuid conflict could result in infinite loop if all uuids are used
    ip="$(int_to_ip $((NETWORK + uuid)))"
    mac="$(int_to_mac "$uuid")"
    gwip="$(int_to_ip "$GATEWAY")"

    ip link add dev veth0_"$cntid" type veth peer name veth1_"$cntid"
    ip link set dev veth0_"$cntid" up
    ip link set veth0_"$cntid" master "$BRIDGE_DEV"
    ip netns add netns_"$cntid"
    ip link set veth1_"$cntid" netns netns_"$cntid"
    ip netns exec netns_"$cntid" ip link set dev lo up
    ip netns exec netns_"$cntid" ip link set veth1_"$cntid" address "$mac"
    ip netns exec netns_"$cntid" ip addr add "$ip/$MASK" dev veth1_"$cntid"
    ip netns exec netns_"$cntid" ip link set dev veth1_"$cntid" up
    ip netns exec netns_"$cntid" ip route add default via "$gwip"
    btrfs subvolume snapshot "$btrfs_path/$1" "$btrfs_path/$cntid" > /dev/null
    mount -o bind /dev/pts "$btrfs_path/$cntid/dev/pts"
    echo nameserver "$gwip" > "$btrfs_path/$cntid/etc/resolv.conf"
    echo "$0 $*" > "$btrfs_path/$cntid/${cntid}.cmd"
    echo "$ip" > "$btrfs_path/$cntid/host-ip-addr"
    cp init "$btrfs_path/$cntid/root/init" || true
    cgcreate -g "$cgroups:/$cntid"

    : "${BOCKER_CPU_SHARE:=512}" && cgset -r cpu.shares="$BOCKER_CPU_SHARE" "$cntid"
    : "${BOCKER_MEM_LIMIT:=512}" && cgset -r memory.limit_in_bytes="$((BOCKER_MEM_LIMIT * 1000000))" "$cntid"

    echo "$cntid"
}

function bocker_execute() {
    cntid="$1"
    shift;
    cgexec -g "$cgroups:$cntid" \
        ip netns exec netns_"$cntid" \
        unshare -fmuip --mount-proc \
        chroot "$btrfs_path/$cntid" \
        /bin/sh -c "source /root/init; $*" || true
}

function bocker_post_run() {
    ip link del dev veth0_"$1"
    ip netns del netns_"$1"
    cgdelete -g "$cgroups:/$1" &> /dev/null || true
}

function bocker_spawn() { #HELP Create a container:\nBOCKER spawn <image_id> <env> <nix-image> <conf-file>
    cntid=$(bocker_pre_run "$1")

    service="$3"
    instance_tag="$btrfs_path/$cntid/var/tmp/instance-tag"

    tar xzf "$repo/${service}.tgz" -C "$btrfs_path/$cntid"
    pushd "$repo/api-config-files" >/dev/null || exit
    mkdir -p "$btrfs_path/$cntid/etc/service-config"
    git archive master | tar -x --strip-components=2 -C "$btrfs_path/$cntid/etc/service-config" "$service/$2"
    popd >/dev/null

    echo -e "$(date +%s.%N)\t$2\t$service\t$(cat "$btrfs_path/$cntid/host-ip-addr")" > "$instance_tag"
    bocker_execute "$cntid" "$service" -c "/etc/service-config/$4" || true
    rm -f "$instance_tag"

    bocker_post_run "$cntid"
}

function bocker_run() { #HELP Create a container:\nBOCKER run <image_id> <command>
    cntid=$(bocker_pre_run "$1")
    bocker_execute "$cntid" "${@:2}" || true
    bocker_post_run "$cntid"
}

function bocker_exec() { #HELP Execute a command in a running container:\nBOCKER exec <container_id> <command>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1
    cid="$(ps ao ppid,pid | awk -v ppid="$(pgrep -f "unshare.*$1")" '$1 == ppid {print $2}')"
    [[ ! "$cid" =~ ^\ *[0-9]+$ ]] && echo "Container '$1' exists but is not running" && exit 1
    nsenter -t "$cid" -m -u -i -n -p chroot "$btrfs_path/$1" "${@:2}"
}

function bocker_kill() { #HELP Kill a running container:\nBOCKER kill <container_id> [<signal>]
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1

    state=$(get_state "$1")
    case $state in
        stopped) echo "Container '$1' is already stopped" ;;
        crashed) echo -e "Container '$1' is in a crashed state, please use the \x1b[1;33mcleanup\x1b[0m command" ;;
        missing) echo "Container '$1' does not exist" ;;
    esac

    sort -nr "/sys/fs/cgroup/cpuacct/$1/tasks" | while read -r proc; do
        kill -SIGKILL -- "$proc" 2>/dev/null || true;
    done
}

function bocker_stop() { #HELP Stop a running container:\nBOCKER stop <container_id>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1

    state=$(get_state "$1")
    case $state in
        stopped) echo "Container '$1' is already stopped" ;;
        crashed) echo -e "Container '$1' is in a crashed state, please use the \x1b[1;33mcleanup\x1b[0m command" ;;
        missing) echo "Container '$1' does not exist" ;;
    esac

    sort -nr "/sys/fs/cgroup/cpuacct/$1/tasks" | while read -r proc; do
        kill -SIGTERM -- "$proc" 2>/dev/null || true;
    done
}

function bocker_cleanup() { #HELP Cleanup unused cgroups, namespaces and veth devices:\nBOCKER cleanup
    #shellcheck disable=SC2012
    ls -rtd "$btrfs_path"/ps_* | while read -r ps; do
        ps=$(basename "$ps")
        if [[ "$(get_state "$ps")" == "crashed" ]]; then
            ip link del "veth0_$ps" &>/dev/null || true
            ip netns del "netns_$ps" &>/dev/null || true
            cgdelete -g "$cgroups:/$ps" &>/dev/null || true
            echo "Cleaned '$ps'"
        fi
    done
}

function bocker_logs() { #HELP View logs from a container:\nBOCKER logs <container_id>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1
    cat "$btrfs_path/$1/$1.log"
}

function bocker_route() { #HELP Ensure outgoing route exists for containers:\nBOCKER route <network-device>
    ip link add "$BRIDGE_DEV" type bridge || true
    ip addr add "$(int_to_ip "$GATEWAY")/$MASK" dev "$BRIDGE_DEV"
    ip link set "$BRIDGE_DEV" up

    iptables -t nat -A POSTROUTING -s "$(int_to_ip "$NETWORK")/$MASK" -o "$1" -j MASQUERADE
}

function bocker_export() { #HELP Expose containers port through host:\nBOCKER export <container_id> <port> <host_port>
    iptables -t nat -A PREROUTING -p tcp -m tcp --dport "$3" -j DNAT \
        --to-destination "$(cat "$btrfs_path/$1/host-ip-addr"):$2" \
        -m comment --comment "host:$3 -> $1:$2"
}

function bocker_commit() { #HELP Commit a container to an image:\nBOCKER commit <container_id> <image_id>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1
    [[ "$(bocker_check "$2")" == 1 ]] && echo "No image named '$2' exists" && exit 1
    bocker_rm "$2" && btrfs subvolume snapshot "$btrfs_path/$1" "$btrfs_path/$2" > /dev/null
    echo "Created: $2"
}

function bocker_name() { #HELP Give a symbolic name to a container:\nBOCKER name <container_id> <name>
    [[ "$(bocker_check "$1")" == 1 ]] && echo "No container named '$1' exists" && exit 1
    ln -s "$btrfs_path/$1" "$btrfs_path/$2"
}

function bocker_help() { #HELP Display this message:\nBOCKER help
    sed -n "s/^.*#HELP\\s//p;" < "$1" | sed "s/\\\\n/\n\t/g;s/$/\n/;s!BOCKER!${1/!/\\!}!g"
}

[[ -z "${1-}" ]] && bocker_help "$0"
case $1 in
    pull|init|rm|images|ps|run|spawn|exec|kill|cleanup|stop|name|logs|route|export|commit) bocker_"$1" "${@:2}" ;;
    *) bocker_help "$0" ;;
esac
